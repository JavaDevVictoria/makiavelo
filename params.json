{"body":"#Makiavelo\r\n\r\nYet Another PHP Web Framework. This is my take at the problem: creating a framework capable of making the developer's life easier and \r\nhelping improve development time.\r\n\r\n##Sample included\r\n\r\nThe current repository contains code within the `app` folder, which is where the web application's code would reside. That is the code for a very basic example of how to use some of the tools provided by the framework to create a (yet again) super basic bloging app.\r\n\r\n##Basic layout \r\n\r\nI've developed this idea over time, after working for a while with Ruby on Rails, so there will be a lot of similarities. I tried to port as many features as I could.\r\n\r\n##jQuery & Bootstrap \r\n\r\nIn order to help with the development speed, the framework comes bundled with the following packages:\r\n\r\n+ jQuery 1.8.2\r\n+ jQueryUI 1.8.23\r\n+ jQuery.timePicker\r\n+ Bootstrap\r\n\r\n##Folder structure\r\n\r\n###App/Controllers\r\n\r\nAll controllers will be store inside this folder.\r\nThe controller files and their classes will follow a simple naming convention:\r\n\r\nSince controllers are usually created to deal with a specific entity (usually but not always), we need to follow these conventions:\r\n\r\n+ Controller file is named as follows: [EntityName]Controller.php\r\n+ Controller class is named as follows: [EntityName]Controller and extends the class `ApplicationController`\r\n\r\n###App/Entities\r\n\r\nThis folder contains all the entities for your application. They'll be auto-required when first called and must follow a naming convention in order to be found: \r\nThis convention is pretty simple, just name your file as follows: [YourEntityName]Class.php\r\n\r\nThe name of the entity should always be camel-case and the first character be uppercased. \r\nFinally, your entity should not have the \"Class\" part on it's name. So for a user entity, you'll have the following:\r\n\r\n+ A file called `UserClass.php` inside the entities folder.\r\n+ A class called `User` inside the `UserClass.php` file. `User` will extend `MakiaveloEntity`.\r\n\r\n###App/Helpers\r\n\r\nThis is a purely organizational folder. In here you can store the helper functions that you create. They'll be accessible from everywhere on your app and the'll be auto-included.\r\n\r\n\r\n###App/Views\r\n\r\nInside this folder Makiavelo will store all the view files. Currently, the framework does not support any kind of templating engine, but we eventually want to add that in.\r\nAs of this writing, all view files will have the extension \"html.php\", thus, they're all php files and you can write php code inside them as you would normally.\r\nThe only thing to take into consideration, is that the files will be stored inside folders named after the corresponding entity.\r\n\r\n###Mappings\r\n\r\nIn order to create a new entity (or model) on Makiavelo, we need to first create a mapping for it. Mappings tell Makiavelo the basic structure of the entity as well as the validations that we'll have in place for that structure.\r\nTo define this mappings, we use YAML files inside the mappings folder.\r\nHere's an example of what a mapping for a user entity would look like:\r\n\r\n_user.yml_\r\n```yaml\r\ncrud:\r\n\tentity:\r\n\t\tname: User\r\n\t\tfields:\r\n\t\t\tfirst_name: string\r\n\t\t\tlast_name: string\r\n\t\t\tbirth_date: date\r\n\t\t\temail: string\r\n\t\t\tpassword: string\r\n\t\tvalidations:\r\n\t\t\tbirth_date: [presence, date]\r\n\t\t\temail: [presence, email]\r\n\t\t\tpassword: [presence]\r\n\r\n```\r\n\r\nOnce we have our _user.yml_ ready, we execute the following command from the terminal:\r\n\r\n`./makiavelo.php g crud user.yml`\r\n\r\nThe framework will then take the following actions:\r\n\r\n+ Create the entity class based on our mapping file and store it on the `entities` folder.\r\n+ Create the controller called UserControllerClass, with the basic crud methods and store it on the `controllers` folder.\r\n+ Create the basic crud routes for our entity and add them to the `routes.php` file.\r\n+ Create the SQL file with the create table statement and store it on the `sql/creates` folder.\r\n+ Create the SQL helper files, with the basic crud functions you'll need to access the database (such as save_user, load_user, etc) and store it on the `sql/helpers` folder.\r\n+ Create the basic views required for all the crud actions (show, edit, new, _form) and store them on the `views/User` folder.\r\n\r\n_That's right!_ Makiavelo just did all that for you!\r\n\r\nThe next logical step would be to load the SQL file into the database, and ideally, Makiavelo would provide a way to do that for you, but right now, that's not implemented, so you'll have to do something like this: `mysql -u[username] -p -h[yourhost] [yourdatabase] < app/sql/creates/user.yml`\r\nThis will go away soon, promiss!!\r\n\r\nAfter loading the SQL into your database, you're ready to start creating new users, cool uh!? Just go to the url created for you, and you'll see what I mean (i.e: yourhost.com/user/new will take you to the new user form).\r\n\r\n###App/SQL/Helpers\r\n\r\nSQL helpers are functions created automatically by the CRUD generator to help the developer access the database and work with the entities easily.\r\nAll helper functions are named using the following convention:\r\n\r\n `[action]_[underscored entity name]`\r\n\r\nFor example, if we created an entity called User using the generator, we'd end up with the following sql helper functions:\r\n\r\n+ __save_user__: Saves the entity on the database, receives the entity as a paremeter.\r\n+ __update_user__: Updates the entity on the database, receives the entity as a paremeter.\r\n+ __delete_user: Deletes the entity from the database. It receives the ID as a paremter.\r\n+ __load_user__: Loads the user from the database and returns the user entity. Recieves an ID as paremeter.\r\n+ __load_user_where__: Loads the user from the database and returns the user entity. Receives a WHERE condition to look for the entity.\r\n+ __list_user__: Returns a list of user entities. Receives 2 optional parameters: order and limit\r\n\r\n###App/SQL/Creates\r\n\r\nInside this folder, Makiavelo will store the SQL files autogenerated when creating a new entity. Currently, these files will need to be manually loaded into the database to create the table.\r\n\r\n###Public\r\n\r\nThe public folder contains all the assets for your application. It'll come with 3 folders which you'll have to use for each time of asset:\r\n\r\n* javascripts: It'll contain all the javascript files.\r\n* img: It'll contain all images for your application.\r\n* stylesheets: It'll contain all css files for your application.\r\n\r\nWhatever your store inside public, you'll be able to access it directly like so: `yourdomain.com/public/yourfolder/yourfile.js`\r\n\r\n###Lib\r\n\r\nThe lib folder is meant to contain all extra code added by the developer and also, the code for the user defined tasks.\r\n\r\n##Using the framework\r\nThere are two sides to Makiavelo:\r\n\r\n+ The command line, which has some usefull commands to do things like creating the tables for the different entities, or creating the basic required files for a standard CRUD system.\r\n+ The web interface, which would the site/app being developed.\r\n\r\n###Command line\r\n\r\nThere are several usefull commands to execute from the command line.\r\nAs of right now, the frameworks provides a file named: `makiavelo.php` which should have execution privileges. Executing that file alone, will list the different commands available:\r\n\r\n+ Generator command (g): This command tells the framework to generate one of many things:\r\n    + CRUD (crud): This attribute for the generator command will tell it to generate the basic structure for a CRUD system for a specific entity.\r\n    + controller: This attribute will tell the generator to create a controller and it's views.\r\n+ Database creator (db:create): It'll connect to our database using the configuration file and it'll create the database for our application\r\n+ Database loader (db:load): It'll create all required tables for all our entities. As of right now, it doesn't allow us to pick which entity, so it'll load all of them.\r\n+ Tasks: Makiavelo has support for tasks (similar to the ones used on RoR with Rake).\r\n\r\n####Some examples:\r\n\r\n__Generating a basic CRUD system for our entity called Post__\r\n```\r\n./makiavelo.php g crud post.yml\r\n```\r\n\r\n__Running a task called \"createSuperUser\" on the task namespace \"Setup\"__\r\n```\r\n./makiavelo.php task setup:createSuperUser\r\n```\r\n\r\n\r\n###Installation/Setup\r\n\r\nIn order to be able to load the application you developed with Makiavelo, you'll need to following:\r\n\r\n+ Allow mod_rewrite on your apache config.\r\n+ Allow the use of .htaccess files\r\n+ Create a virtual host for your app, pointing to it's \"public\" folder\r\n+ Configure the database access on the `config/database.yml` file. Right now, only MySQL is supported.\r\n+ Configure your `/etc/hosts` file to point the new virtual host to your localhost\r\n+ ????\r\n+ Profit!\r\n\r\n_NOTE_: I need to add more details to each point, but it should be pretty straight forward.\r\n\r\n#More details\r\n\r\n##Routes\r\n\r\nThe aim regarding routes, is to keep them REST oriented. Right now, the only two verbs supported are GET and POST, so we need to work on that front.\r\n\r\nWhen using the CRUD generator, the system will automatically generate the required routes for all of the basic CRUD operations and it'll store that information on the `routes.php` file, located on the `config` folder.\r\n\r\nAn example of what can be found in that file is:\r\n\r\n```php\r\n$_ROUTES[] = array(\r\n\t\"list\" => array(\"url\" => \"/post/\", \"controller\" => \"Post\", \"action\" => \"index\"),\r\n\t\"create\" => array(\"url\" => \"/post/create\", \"controller\" => \"Post\", \"action\" => \"create\", \"via\" => \"post\", \"role\" => \"user\"),\r\n\t\"new\" => array(\"url\" => \"/post/new\", \"controller\" => \"Post\", \"action\" => \"new\", \"role\" => \"user\"),\r\n\t\"retrieve\" => array(\"url\" => \"/post/:id\", \"controller\" => \"Post\", \"action\" => \"show\", \"via\" => \"get\", \"role\" => \"user\" ),\r\n\t\"update\" => array(\"url\" => \"/post/:id/edit\", \"controller\" => \"Post\", \"action\" => \"edit\", \"role\" => \"user\"),\r\n\t\"delete\" => array(\"url\" => \"/post/:id/delete\", \"controller\" => \"Post\", \"action\" => \"delete\", \"via\" => \"post\", \"role\" => \"user\")\r\n\t); \r\n\r\n```\r\n\r\nThat will create all the required routes for every action needed.\r\nHere is an explanation of each of the keys of those arrays:\r\n\r\n+ url: This will contain the URL for the action, can be anything, and can contain attributes in the form of `:ATTR_NAME`.\r\n+ controller: The name of the controller, without the \"Controller\" part (all controllers have that word on the class name).\r\n+ action: The name of the method to execute from the controller. It'll map to a method called: `ACTION_NAMEAction` (i,e: indexAction).\r\n+ via: This is an optional parameter, and will force the route to work using the specified HTTP verb (only values supported right now are `get` and `post`). The default value here is `get`.\r\n+ role: Another optional parameter, usefull when your application needs to filter out actions based on the role of the user. \r\n\r\nEach entry in the array, will auto-generate a url helper function, so you can use that instead of hard-coding the urls all throught the site.\r\n\r\n###URL helpers\r\n\r\nThe helpers are created dinamically, and they basically return the url, replacing any attribute with the correct value.\r\nHere is how the helper functions are named:\r\n\r\n```\r\n[underscored_controller_name]_[underscored_action_name]_path\r\n```\r\nFor instance, using the above example, we will have:\r\n\r\n+ `post_list_path()` to redirect to the list of all posts.\r\n+ `post_create_path()` will save the post information.\r\n+ `post_retrieve_path($post)` will take us to the show view of the post controller, and it'll grab the attribute `id` from the entity passed as a parameter.\r\n+ and so on.\r\n\r\nThere are other url helper functions are can be use, when, for instance, you need to get the edit path for a particular entity, but you don't know the entity's class.\r\n\r\nThese helpers are:\r\n\r\n+ __show_path_for__ : Receives an entity as parameter, and it'll return the right path for the show view of that entity.\r\n+ __edit_path_for__ : Receives an entity as parameter, and it'll return the right path for the edit  view of that entity.\r\n+ __delete_path_for__ : Receives an entity as parameter, and it'll return the right path for the delete action of that entity.\r\n\r\n##HTML helpers\r\nMakiavelo provides some basic html helper functions to ease the development process.\r\n\r\nThere are two types of functions, the ones that require an entity and the generic ones.\r\n\r\n####Entity related functions\r\n\r\n\r\n+ form_for\r\n\r\nThe following entity html helpers receive the entity as the first parameter, the name of the property as the second one, an optional label value (it'll add a label element for that form element) and finally an array of html options (for setting id, class, html attributes, etc).\r\n\r\n+ text_field\r\n+ password_field\r\n+ hidden_field\r\n+ select_field\r\n+ time_field: This helper will create an input field (of type text) that has a timePicker associated with it.\r\n+ date_field: This helper will create an input field (of type text) that has a jQuery calendar associated with it.\r\n+ file_field \r\n+ boolean_field\r\n+ email_field\r\n\r\n\r\n###Generic helper functions\r\n\r\n+ form_for_tag\r\n+ end_form_tag\r\n+ text_field_tag\r\n+ password_field_tag\r\n+ hidden_field_tag\r\n+ select_field_tag\r\n+ time_field_tag\r\n+ date_field_tag\r\n+ file_field _tag\r\n+ boolean_field_tag\r\n+ email_field_tag\r\n+ link_to\r\n+ submit\r\n+ image_tag\r\n\r\n##Validations\r\n\r\nMakiavelo allows for easy validation on entities before saving them to the database. In order to set the validations, you need to set a specific private attribute called `$validations`.\r\nThat attribute needs to have the following structure:\r\n\r\n```php\r\n$validations = array(\"attr_name\" => array(\"validation_name_1\", \"validation_name_2\", ....))\r\n```\r\n\r\nCurrently the following validations are supported:\r\n\r\n+ presence\r\n+ email\r\n+ integer\r\n\r\nThe plan is to allow for custom validations to be created by the developer.\r\n\r\n_A simple example_: The following code will setup the Post entity to validate for it's content, title and owner's email fields:\r\n\r\n```php\r\nclass PostClass extends MakiaveloEntity {\r\n\t\r\n\tprivate $title;\r\n\tprivate $content;\r\n\tprivate $owner_email;\r\n\r\n\tstatic public $validations = array(\"title\"=> array('presence'),\r\n\t\t\t\t\t\t\t\t\t   \"content\"=> array('presence'),\r\n\t\t\t\t\t\t\t\t\t   \"owner_email\"=> array('presence', 'email'),\r\n\t\t\t\t\t\t\t\t);\r\n}\r\n```\r\n\r\n##Security\r\n\r\nCurrently Makiavelo supports the definition of \"roles\" for a given entity (normally a user) and it'll create a hierarchy, based on the order in which the roles are defined.\r\nLets look at an example of defining roles:\r\n\r\n\r\n```php\r\n $__SECURITY = array(\r\n\t\"roles\" => array(\"anonymous\", \"user\", \"admin\"),\r\n\t\"class_name\" => \"User\"\r\n\t);\r\n\r\n```\r\nUsing the special array `$__SECURITY` we're able to set the different access roles, and the entity which will be used with them.\r\nAccording to our definition, the \"anonymous\" user role is assigned to the new visitor before they login. They, after they login, a role will be assigned. And as expected, the hierarchy is: admin > user > anonymous\r\n\r\n##Allowing or denying access to a specific role\r\n\r\nHow do we use the above information to allow or deny certain roles from accesing part of our site/web app?\r\nEasy! just add the minimum allowed role on the routes file, for each route you want to protect. \r\nLets look at an example:\r\n\r\n```php\r\n$_ROUTES[] = array(\r\n\t\"list\" => array(\"url\" => \"/post/\", \"controller\" => \"Post\", \"action\" => \"index\", \"role\" => \"user\"),\r\n\t\"create\" => array(\"url\" => \"/post/create\", \"controller\" => \"Post\", \"action\" => \"create\", \"via\" => \"post\", \"role\" => \"admin\"),\r\n\t\"new\" => array(\"url\" => \"/post/new\", \"controller\" => \"Post\", \"action\" => \"new\", \"role\" => \"admin\"),\r\n\t\"retrieve\" => array(\"url\" => \"/post/:id\", \"controller\" => \"Post\", \"action\" => \"show\", \"via\" => \"get\", \"role\" => \"user\" ),\r\n\t\"update\" => array(\"url\" => \"/post/:id/edit\", \"controller\" => \"Post\", \"action\" => \"edit\", \"role\" => \"admin\"),\r\n\t\"delete\" => array(\"url\" => \"/post/:id/delete\", \"controller\" => \"Post\", \"action\" => \"delete\", \"via\" => \"post\", \"role\" => \"admin\")\r\n\t); \r\n```\r\n\r\nWith the above configuration, we're allowing only logged in users to interact with the post urls. And only admins can create d, update and delte posts.\r\n\r\n##Database connection\r\n\r\nCurrently Makiavelo only supports MySQL databases.\r\nThe connection information is defined inside the `database.yml` file, located on the `config` folder.\r\n\r\n##Localization\r\n\r\nMakiavelo tries to handle internationalization just as Rails does. Inside the project, there is a sub-project (that we should eventually move out into its own project) called I18n, which provides the same helpers.\r\n\r\n###Locale files\r\n\r\nInside the `config/locales/` folder the use must create the different locale files, organized by folders named after the desired language. \r\ni.e The folder _config/locales/en_ will contain all english localization strings, and a _config/locales/es_ will have all the spanish equivalents.\r\nThe format for the localization files is the same as the one used by I18n on rails, a YAML file with the following structure:\r\n\r\n```yml\r\nen:\r\n\tusuario:\r\n\t\tatributos:\r\n\t\t\tnombre: Name\r\n\t\t\tedad: Age\r\n``` \r\n\r\n###Helper functions\r\n\r\nThe following helper functions are provided:\r\n\r\n+ __t__: Short for `I18n::translate`, which receives a string parameter that acts as the key path inside the yml and returns the translation string or an error message if the key path is invalid. Using the yml from above, you could grab the translation for the `nombre` attribute of `usuario` like so: `t(\"usuario.atributos.nombre\")`\r\n+ __l__: Short for `I18n::localize`, which takes a time or date value and returns a string formatted in the right format.\r\n\r\n###Setting the current locale\r\n\r\nThe I18n module provides a `config` method, which takes an array as an attribute. the array provided, will contain all the configuration options for the module.\r\n\r\nThe current supported configuration values are:\r\n\r\n+ __locale__: The desired locale to use.\r\n\r\nSo, configuring the locale to __es__ would be done like this: \r\n```php\r\n I18n::config(array(\"locale\" => \"es\"));\r\n```\r\n\r\n##Flash\r\n\r\nMakiavelo tries to borrow the concept of flash message from Rails (and other frameworks) using the `flash` object available to the developer inside every controller.\r\nThe flash object implements the magic method `__call`, so the way to use this object is to call the method desired with the \"set\" prefix when we want to set the message, and the \"get\" prefix when we want to get the saved message.\r\nWe'll only be able to get the message once, after that, it'll be removed from the current session.\r\n\r\n_Example_\r\n\r\n```php\r\n//... code snippet inside a controller\r\n$this->flash->setError(\"There was a problem saving the user, please try again\");\r\n//...more code goes here...\r\n```\r\n\r\nNow, inside the view:\r\n```php\r\n<p class=\"error\"><?=$this->flash->getError()?></p>\r\n``` \r\n\r\nThat example uses the \"getError\" and \"setError\" methods, but they could've easily been \"getMyErrorMessage\" and \"setMyErrorMessage\".\r\n\t\r\n##Tasks\r\n\r\nMakiavelo attempts to \"borrow\" the concept of tasks from Ruby on Rails, by allowing the developer to define custom methods that can be executed from the command line.\r\n\r\nLets look at an example of how you'd execute a task, and then, we'll talk about how to define one:\r\n\r\n`./makiavelo.php task users:createFirsUser`\r\n\r\nIn that line, we're telling Makiavelo to execute a task within the \"users\" namespace, called \"createFirstUser\". That translates to the execution of the method \"createFirstUser\" from the class \"UsersTask\".\r\n\r\nIn order to define a task, the dev will have to following these conventions:\r\n\r\n+ The file will have to be saved inside the __/lib/tasks__ folder.\r\n+ The file will have to be named like this: [underscored namespace]_task.php\r\n+ The class will have to be called [CamelCased namespace]Task.\r\n\r\n\r\n#To-Do\r\n\r\nMakiavelo is an ongoing project, and as such, it still requires a lot of testing, refactor and rethinking of modules. \r\nSome of the areas that need mayor work are:\r\n\r\n+ __DB Access__: I'm currently using mysql_* functions, but in the future I wanted to improve the code, by using PDO and forgetting about the SQL helpers that Makiavelo creates for every entity.\r\n+ __Routes__: Currently the global routes array feels wrong, there should be an easier, more elegant way of handling routes.\r\n+ __Templating__: The original idea for Makiavelo, was to force the use of HAML, but the current implementation made it quite difficult to implement, so we need to refactor the way views and partials are handled, in order to be able to use HAML and any other templating engine.\r\n+ __Lots more!__\r\n\r\n#Contribute\r\nPlease, feel free to  fork, improve and create a pull request! All contributions are welcomed! :)","google":"","tagline":"PHP web framework","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Makiavelo"}